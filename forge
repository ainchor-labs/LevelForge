#!/bin/bash
# LevelForge CLI - A YAML-driven game engine
set -e

VERSION="0.1.0"

# Resolve the LevelForge engine directory
FORGE_ENGINE_DIR="${LEVELFORGE_HOME:-/mnt/Projects/Ainchor/LevelForge}"
PROJECT_DIR="$(pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[forge]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[forge]${NC} $1"; }
log_error() { echo -e "${RED}[forge]${NC} $1"; }
log_step()  { echo -e "${CYAN}[forge]${NC} $1"; }

# ============================================================================
# Config Parsing (uses a simple approach - reads YAML with grep/sed)
# ============================================================================

get_config_value() {
    local key="$1"
    local default="$2"
    local config_file="$PROJECT_DIR/config.yaml"

    if [ ! -f "$config_file" ]; then
        echo "$default"
        return
    fi

    # Simple YAML parsing for flat values
    local value
    value=$(grep -E "^${key}:" "$config_file" 2>/dev/null | sed 's/^[^:]*:[[:space:]]*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'")

    if [ -z "$value" ]; then
        echo "$default"
    else
        echo "$value"
    fi
}

get_game_type() {
    get_config_value "type" "2d"
}

get_game_name() {
    local config_file="$PROJECT_DIR/config.yaml"
    if [ -f "$config_file" ]; then
        # Try to get game.name
        grep -A1 "^game:" "$config_file" 2>/dev/null | grep "name:" | sed 's/^[^:]*:[[:space:]]*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'" || echo "game"
    else
        echo "game"
    fi
}

get_starting_screen() {
    local config_file="$PROJECT_DIR/config.yaml"
    if [ -f "$config_file" ]; then
        grep -A3 "^game:" "$config_file" 2>/dev/null | grep "starting_screen:" | sed 's/^[^:]*:[[:space:]]*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'" || echo "title"
    else
        echo "title"
    fi
}

# ============================================================================
# Screen Parsing and Validation
# ============================================================================

SCREENS_DIR="$PROJECT_DIR/screens"

get_screen_value() {
    local screen_file="$1"
    local key="$2"
    local default="$3"

    if [ ! -f "$screen_file" ]; then
        echo "$default"
        return
    fi

    local value
    value=$(grep -E "^[[:space:]]*${key}:" "$screen_file" 2>/dev/null | head -1 | sed 's/^[^:]*:[[:space:]]*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'")

    if [ -z "$value" ]; then
        echo "$default"
    else
        echo "$value"
    fi
}

get_screen_name() {
    local screen_file="$1"
    # Look for screen.name in the file, strip comments
    grep -A1 "^screen:" "$screen_file" 2>/dev/null | grep "name:" | sed 's/^[^:]*:[[:space:]]*//' | sed 's/#.*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'" || basename "$screen_file" .yaml
}

get_screen_type() {
    local screen_file="$1"
    # Look for screen.type, strip comments
    grep -A2 "^screen:" "$screen_file" 2>/dev/null | grep "type:" | head -1 | sed 's/^[^:]*:[[:space:]]*//' | sed 's/#.*//' | sed 's/[[:space:]]*$//' | tr -d '"' | tr -d "'" || echo "unknown"
}

validate_screen() {
    local screen_file="$1"
    local screen_name
    local screen_type
    local errors=0

    if [ ! -f "$screen_file" ]; then
        log_error "Screen file not found: $screen_file"
        return 1
    fi

    screen_name=$(get_screen_name "$screen_file")
    screen_type=$(get_screen_type "$screen_file")

    # Check for required screen: block
    if ! grep -q "^screen:" "$screen_file"; then
        log_error "  Missing 'screen:' block in $(basename "$screen_file")"
        errors=$((errors + 1))
    fi

    # Check screen name matches filename
    local filename
    filename=$(basename "$screen_file" .yaml)
    if [ "$screen_name" != "$filename" ]; then
        log_warn "  Screen name '$screen_name' doesn't match filename '$filename'"
    fi

    # Validate screen type
    case "$screen_type" in
        menu|gameplay|cutscene|pause)
            ;;
        unknown|"")
            log_warn "  Missing or unknown screen type in $(basename "$screen_file")"
            ;;
        *)
            log_warn "  Unrecognized screen type '$screen_type' in $(basename "$screen_file")"
            ;;
    esac

    # Check for background settings
    if ! grep -q "^background:" "$screen_file"; then
        log_warn "  No 'background:' defined in $(basename "$screen_file")"
    fi

    [ $errors -eq 0 ]
}

list_screens() {
    if [ ! -d "$SCREENS_DIR" ]; then
        log_warn "No screens directory found at: $SCREENS_DIR"
        return 1
    fi

    local screen_files
    screen_files=$(find "$SCREENS_DIR" -maxdepth 1 -name "*.yaml" -type f 2>/dev/null | sort)

    if [ -z "$screen_files" ]; then
        log_warn "No screen files found in: $SCREENS_DIR"
        return 1
    fi

    local starting_screen
    starting_screen=$(get_starting_screen)

    echo -e "${BLUE}Screens${NC} in $SCREENS_DIR:"
    echo ""

    while IFS= read -r screen_file; do
        local name type marker=""
        name=$(get_screen_name "$screen_file")
        type=$(get_screen_type "$screen_file")

        if [ "$name" = "$starting_screen" ]; then
            marker="${GREEN}(starting)${NC}"
        fi

        echo -e "  ${CYAN}$(printf '%-20s' "$name")${NC} type: $(printf '%-10s' "$type") $marker"
    done <<< "$screen_files"

    echo ""
}

validate_all_screens() {
    if [ ! -d "$SCREENS_DIR" ]; then
        log_error "No screens directory found at: $SCREENS_DIR"
        return 1
    fi

    local screen_files
    screen_files=$(find "$SCREENS_DIR" -maxdepth 1 -name "*.yaml" -type f 2>/dev/null | sort)

    if [ -z "$screen_files" ]; then
        log_error "No screen files found in: $SCREENS_DIR"
        return 1
    fi

    local starting_screen total_screens=0 valid_screens=0 starting_found=false
    starting_screen=$(get_starting_screen)

    log_info "Validating screens..."
    echo ""

    while IFS= read -r screen_file; do
        total_screens=$((total_screens + 1))
        local name
        name=$(get_screen_name "$screen_file")

        echo -e "  Checking ${CYAN}$(basename "$screen_file")${NC}..."

        if validate_screen "$screen_file"; then
            valid_screens=$((valid_screens + 1))
            log_info "    Valid"
        fi

        if [ "$name" = "$starting_screen" ]; then
            starting_found=true
        fi
    done <<< "$screen_files"

    echo ""

    # Check if starting screen exists
    if [ "$starting_found" = false ]; then
        log_error "Starting screen '$starting_screen' not found in screens directory!"
        log_info "  Create screens/$starting_screen.yaml or update starting_screen in config.yaml"
    else
        log_info "Starting screen '$starting_screen' found"
    fi

    echo ""
    log_info "Validation complete: $valid_screens/$total_screens screens valid"
}

screens_command() {
    local subcommand="${1:-list}"

    case "$subcommand" in
        list|ls)
            list_screens
            ;;
        validate|check)
            validate_all_screens
            ;;
        *)
            log_error "Unknown screens subcommand: $subcommand"
            echo ""
            echo "Usage: forge screens <subcommand>"
            echo ""
            echo "Subcommands:"
            echo "  list, ls       List all screen files"
            echo "  validate       Validate all screen configurations"
            exit 1
            ;;
    esac
}

# ============================================================================
# Build Functions
# ============================================================================

ensure_engine_built() {
    local game_type="$1"
    log_step "Ensuring engine libraries are built..."

    cd "$FORGE_ENGINE_DIR"

    # Build required libraries based on game type
    if [ "$game_type" = "2d" ]; then
        ./build.sh 2d 2>/dev/null || {
            log_info "Building 2D engine dependencies..."
            ./build.sh 2d
        }
    else
        ./build.sh 3d 2>/dev/null || {
            log_info "Building 3D engine dependencies..."
            ./build.sh 3d
        }
    fi

    cd "$PROJECT_DIR"
}

build_project() {
    local game_type
    game_type=$(get_game_type)
    local output_name="game"

    log_info "Building ${game_type^^} project..."

    # Ensure engine is ready
    ensure_engine_built "$game_type"

    # Find the main source file
    local source_file="main.cpp"
    if [ ! -f "$PROJECT_DIR/$source_file" ]; then
        log_error "No main.cpp found in project directory"
        exit 1
    fi

    log_step "Compiling $source_file..."

    if [ "$game_type" = "2d" ]; then
        # Determine box2d lib directory
        BOX2D_LIB_DIR="$FORGE_ENGINE_DIR/box2d/lib64"
        [ ! -d "$BOX2D_LIB_DIR" ] && BOX2D_LIB_DIR="$FORGE_ENGINE_DIR/box2d/lib"

        g++ "$PROJECT_DIR/$source_file" -o "$PROJECT_DIR/$output_name" \
            -I"$FORGE_ENGINE_DIR/raylib/include" \
            -I"$FORGE_ENGINE_DIR/box2d/include" \
            -I"$FORGE_ENGINE_DIR/yaml/include" \
            -L"$FORGE_ENGINE_DIR/raylib/lib" \
            -L"$BOX2D_LIB_DIR" \
            -L"$FORGE_ENGINE_DIR/yaml/lib" \
            -l:libraylib.a \
            -lbox2d \
            -l:libyaml-cpp.a \
            -lGL -lm -lpthread -ldl -lrt -lX11
    else
        g++ "$PROJECT_DIR/$source_file" -o "$PROJECT_DIR/$output_name" \
            -std=c++17 \
            -O2 -DNDEBUG \
            -DJPH_PROFILE_ENABLED \
            -DJPH_DEBUG_RENDERER \
            -DJPH_OBJECT_STREAM \
            -I"$FORGE_ENGINE_DIR/raylib/include" \
            -I"$FORGE_ENGINE_DIR/jolt" \
            -I"$FORGE_ENGINE_DIR/yaml/include" \
            -L"$FORGE_ENGINE_DIR/raylib/lib" \
            -L"$FORGE_ENGINE_DIR/jolt/Build/Linux_Release" \
            -L"$FORGE_ENGINE_DIR/yaml/lib" \
            -l:libraylib.a \
            -l:libJolt.a \
            -l:libyaml-cpp.a \
            -lGL -lm -lpthread -ldl -lrt -lX11
    fi

    log_info "Build complete: ./$output_name"
}

# ============================================================================
# Run Functions
# ============================================================================

run_project() {
    local output_name="game"

    if [ ! -f "$PROJECT_DIR/$output_name" ]; then
        log_warn "No executable found, building first..."
        build_project
    fi

    log_info "Running game..."
    cd "$PROJECT_DIR"
    ./"$output_name"
}

# ============================================================================
# Project Scaffolding
# ============================================================================

init_project() {
    local project_name="${1:-my_game}"
    local game_type="${2:-2d}"

    log_info "Initializing new $game_type project: $project_name"

    mkdir -p "$project_name"
    cd "$project_name"

    # Create config.yaml
    cat > config.yaml << EOF
# LevelForge Game Configuration

game:
  name: "$project_name"
  version: "1.0.0"
  starting_screen: "title"

type: $game_type

window:
  width: 1280
  height: 720
  title: "$project_name"
  resizable: true
  fullscreen: false
  vsync: true

performance:
  target_fps: 60

build:
  targets:
    - linux
    - windows
EOF

    # Create screens directory with sample screens
    mkdir -p screens

    # Create title screen
    cat > screens/title.yaml << 'EOF'
# Screen Configuration - Title Screen

screen:
  name: "title"
  type: "menu"

background:
  color: [30, 30, 40]

elements:
  - type: "text"
    id: "game_title"
    content: "My Game"
    position: [640, 200]
    font_size: 60
    color: [255, 255, 255]
    anchor: "center"

  - type: "text"
    id: "subtitle"
    content: "Press ENTER to Start"
    position: [640, 300]
    font_size: 24
    color: [180, 180, 180]
    anchor: "center"

  - type: "button"
    id: "start_button"
    content: "Start Game"
    position: [640, 400]
    size: [200, 50]
    font_size: 20
    color: [255, 255, 255]
    background: [60, 120, 200]
    action: "goto_screen:level_1"
    anchor: "center"

  - type: "button"
    id: "quit_button"
    content: "Quit"
    position: [640, 470]
    size: [200, 50]
    font_size: 20
    color: [255, 255, 255]
    background: [100, 100, 100]
    action: "quit"
    anchor: "center"

input:
  - key: "ENTER"
    action: "goto_screen:level_1"
  - key: "ESCAPE"
    action: "quit"

transitions:
  enter: "fade_in"
  exit: "fade_out"
  duration: 0.3
EOF

    # Create level_1 screen
    cat > screens/level_1.yaml << 'EOF'
# Screen Configuration - Level 1

screen:
  name: "level_1"
  type: "gameplay"

background:
  color: [20, 20, 30]

physics:
  enabled: true
  gravity: [0, 9.8]

camera:
  type: "static"
  zoom: 1.0

entities:
  - type: "player"
    id: "player"
    position: [100, 500]

  - type: "platform"
    id: "ground"
    position: [640, 680]
    size: [1280, 40]
    static: true

ui:
  - type: "text"
    id: "level_label"
    content: "Level 1"
    position: [20, 20]
    font_size: 24
    color: [255, 255, 255]

input:
  - key: "ESCAPE"
    action: "goto_screen:title"
EOF

    log_info "Created screens directory with title.yaml and level_1.yaml"

    # Create main.cpp template
    cat > main.cpp << 'EOF'
#include "raylib.h"
#include "yaml-cpp/yaml.h"
#include <string>
#include <iostream>

struct GameConfig {
    std::string name;
    std::string type;
    int windowWidth;
    int windowHeight;
    std::string windowTitle;
    bool resizable;
    bool fullscreen;
    bool vsync;
    int targetFps;
};

GameConfig LoadConfig(const std::string& path) {
    GameConfig config;
    try {
        YAML::Node yaml = YAML::LoadFile(path);
        config.name = yaml["game"]["name"].as<std::string>("Untitled Game");
        config.type = yaml["type"].as<std::string>("2d");
        auto window = yaml["window"];
        config.windowWidth = window["width"].as<int>(1280);
        config.windowHeight = window["height"].as<int>(720);
        config.windowTitle = window["title"].as<std::string>(config.name);
        config.resizable = window["resizable"].as<bool>(true);
        config.fullscreen = window["fullscreen"].as<bool>(false);
        config.vsync = window["vsync"].as<bool>(true);
        config.targetFps = yaml["performance"]["target_fps"].as<int>(60);
    } catch (const YAML::Exception& e) {
        std::cerr << "Error loading config: " << e.what() << std::endl;
        config = {"Untitled", "2d", 1280, 720, "Untitled", true, false, true, 60};
    }
    return config;
}

int main() {
    GameConfig config = LoadConfig("config.yaml");

    unsigned int flags = 0;
    if (config.resizable) flags |= FLAG_WINDOW_RESIZABLE;
    if (config.fullscreen) flags |= FLAG_FULLSCREEN_MODE;
    if (config.vsync) flags |= FLAG_VSYNC_HINT;
    SetConfigFlags(flags);

    InitWindow(config.windowWidth, config.windowHeight, config.windowTitle.c_str());
    SetTargetFPS(config.targetFps);

    // Game loop
    while (!WindowShouldClose()) {
        // Update

        // Draw
        BeginDrawing();
        ClearBackground(RAYWHITE);
        DrawText("Hello, LevelForge!", 40, 40, 30, DARKGRAY);
        DrawText(TextFormat("FPS: %d", GetFPS()), 40, 80, 20, GRAY);
        EndDrawing();
    }

    CloseWindow();
    return 0;
}
EOF

    log_info "Project created at: $project_name/"
    log_info "Run 'cd $project_name && forge build' to build"
}

# ============================================================================
# Clean Functions
# ============================================================================

clean_project() {
    log_info "Cleaning project..."
    rm -f "$PROJECT_DIR/game"
    rm -f "$PROJECT_DIR"/*.o
    log_info "Clean complete"
}

# ============================================================================
# Usage
# ============================================================================

usage() {
    echo -e "${BLUE}LevelForge${NC} v$VERSION - YAML-driven game engine"
    echo ""
    echo "Usage: forge <command> [options]"
    echo ""
    echo "Commands:"
    echo "  build              Build the current project"
    echo "  run                Build and run the current project"
    echo "  clean              Remove build artifacts"
    echo "  init <name> [type] Create a new project (type: 2d or 3d)"
    echo "  screens [cmd]      Manage screen configurations"
    echo "    list             List all screens in project"
    echo "    validate         Validate screen YAML files"
    echo ""
    echo "Examples:"
    echo "  forge init my_game 2d    # Create new 2D project"
    echo "  forge build              # Build current project"
    echo "  forge run                # Run current project"
    echo "  forge screens list       # List all screen files"
    echo "  forge screens validate   # Validate screen configs"
    echo ""
    echo "Environment:"
    echo "  LEVELFORGE_HOME    Path to LevelForge engine (default: $FORGE_ENGINE_DIR)"
}

# ============================================================================
# Entry Point
# ============================================================================

case "${1:-}" in
    build)
        build_project
        ;;
    run)
        run_project
        ;;
    clean)
        clean_project
        ;;
    init)
        init_project "${2:-my_game}" "${3:-2d}"
        ;;
    screens)
        screens_command "${2:-list}"
        ;;
    version|--version|-v)
        echo "forge v$VERSION"
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        log_error "Unknown command: $1"
        usage
        exit 1
        ;;
esac
